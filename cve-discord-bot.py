#!/usr/bin/env python3
"""
CVE Discord Bot (Persistent) - NVD API v2.0 (CRITICAL only)
- Uses NIST NVD API Key
- Posts new CRITICAL CVEs to Discord
- Prevents duplicates using a local file
- Runs continuously on a timer
- Only shows CVEs published from January 9th, 2026 onward
- Handles Discord webhook rate limiting (429) with retry/backoff
"""

import requests
import time
import datetime
import os
from typing import Any, Dict, List, Optional, Tuple

# ================= CONFIG =================

NIST_API_KEY = "YOUR_NIST_API_KEY_HERE"
DISCORD_WEBHOOK_URL = "https://discord.com/api/webhooks/XXXX/XXXX"

CHECK_INTERVAL_HOURS = 6
SEEN_CVE_FILE = "posted_cves.txt"

# NVD API v2.0 base URL
NVD_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"

# Only include CVEs published from Jan 9, 2026 onward (UTC, timezone-aware)
MIN_PUBLISHED_DATE = datetime.datetime(2026, 1, 9, tzinfo=datetime.timezone.utc)

# Discord rate limiting / throttling
DISCORD_POST_DELAY_SECONDS = 3     # fixed delay between successful posts
DISCORD_MAX_RETRIES = 5            # retries when Discord says 429 or transient failure

# ==========================================


def iso_z(dt: datetime.datetime) -> str:
    """Return ISO-8601 with milliseconds and Z."""
    dt = dt.astimezone(datetime.timezone.utc)
    return dt.strftime("%Y-%m-%dT%H:%M:%S.000Z")


def load_seen_cves() -> set:
    if not os.path.exists(SEEN_CVE_FILE):
        return set()
    with open(SEEN_CVE_FILE, "r", encoding="utf-8") as f:
        return set(line.strip() for line in f if line.strip())


def save_seen_cve(cve_id: str) -> None:
    with open(SEEN_CVE_FILE, "a", encoding="utf-8") as f:
        f.write(cve_id + "\n")


def extract_description(cve_obj: Dict[str, Any]) -> str:
    descs = cve_obj.get("descriptions", []) or []
    for d in descs:
        if d.get("lang") == "en" and d.get("value"):
            return d["value"]
    if descs and descs[0].get("value"):
        return descs[0]["value"]
    return "(No description provided.)"


def extract_cvss(cve_obj: Dict[str, Any]) -> Tuple[Optional[float], Optional[str]]:
    metrics = cve_obj.get("metrics") or {}
    for key in ("cvssMetricV31", "cvssMetricV30", "cvssMetricV2"):
        arr = metrics.get(key)
        if isinstance(arr, list) and arr:
            cvss_data = (arr[0] or {}).get("cvssData") or {}
            return cvss_data.get("baseScore"), cvss_data.get("vectorString")
    return None, None


def fetch_critical_cves() -> List[Dict[str, Any]]:
    headers = {"apiKey": NIST_API_KEY} if NIST_API_KEY and NIST_API_KEY != "YOUR_NIST_API_KEY_HERE" else {}

    now_utc = datetime.datetime.now(datetime.timezone.utc)

    # NVD date window limit (~120 days)
    pub_start = max(MIN_PUBLISHED_DATE, now_utc - datetime.timedelta(days=119))

    params = {
        "cvssV3Severity": "CRITICAL",
        "resultsPerPage": 200,
        "pubStartDate": iso_z(pub_start),
        "pubEndDate": iso_z(now_utc),
        "noRejected": ""
    }

    try:
        r = requests.get(NVD_API_URL, headers=headers, params=params, timeout=30)
        if r.status_code >= 400:
            print(f"[!] NVD error {r.status_code}")
            print(f"    URL: {r.url}")
            print(f"    Body (first 400 chars): {r.text[:400]!r}")
            r.raise_for_status()

        return r.json().get("vulnerabilities", []) or []
    except Exception as e:
        print(f"[!] Error querying NVD: {e}")
        return []


def build_discord_payload(entry: Dict[str, Any]) -> Dict[str, Any]:
    cve = entry.get("cve") or {}
    cve_id = cve.get("id", "UNKNOWN")
    published = cve.get("published", "UNKNOWN")
    description = extract_description(cve)

    score, vector = extract_cvss(cve)
    score = score if score is not None else "N/A"
    vector = vector if vector is not None else "N/A"

    url = f"https://nvd.nist.gov/vuln/detail/{cve_id}"

    return {
        "username": "CVE Monitor",
        "embeds": [{
            "title": f"ðŸš¨ {cve_id}",
            "url": url,
            "color": 16711680,
            "description": (
                f"**Severity:** CRITICAL\n"
                f"**CVSS:** {score}\n"
                f"**Vector:** `{vector}`\n"
                f"**Published:** {published}\n\n"
                f"{description[:350]}{'...' if len(description) > 350 else ''}\n\n"
                f"[View on NVD]({url})"
            ),
            "footer": {"text": "NIST NVD â€¢ Automated Feed"}
        }]
    }


def _discord_retry_after_seconds(resp: requests.Response) -> float:
    """
    Discord returns retry timing either in header Retry-After (seconds or ms-ish)
    or JSON body { "retry_after": seconds, ... }.
    We'll prefer JSON if present, otherwise header, otherwise a safe default.
    """
    # Try JSON body
    try:
        data = resp.json()
        ra = data.get("retry_after")
        if isinstance(ra, (int, float)) and ra > 0:
            return float(ra)
    except Exception:
        pass

    # Try header
    h = resp.headers.get("Retry-After")
    if h:
        try:
            return float(h)
        except Exception:
            pass

    return 2.0


def post_to_discord(payload: Dict[str, Any]) -> bool:
    """
    Posts to Discord with:
    - fixed small delay between successful posts
    - automatic handling of 429 rate limits with backoff + retry
    Returns True on success, False on permanent failure.
    """
    for attempt in range(1, DISCORD_MAX_RETRIES + 1):
        try:
            resp = requests.post(DISCORD_WEBHOOK_URL, json=payload, timeout=15)

            # Rate limited
            if resp.status_code == 429:
                wait_s = _discord_retry_after_seconds(resp)
                print(f"[!] Discord rate limited (429). Retry-After: {wait_s:.2f}s (attempt {attempt}/{DISCORD_MAX_RETRIES})")
                time.sleep(wait_s)
                continue

            # Other error
            if resp.status_code >= 400:
                print(f"[!] Discord error {resp.status_code} (attempt {attempt}/{DISCORD_MAX_RETRIES})")
                print(f"    Body (first 400 chars): {resp.text[:400]!r}")

                # Retry transient server errors
                if 500 <= resp.status_code <= 599 and attempt < DISCORD_MAX_RETRIES:
                    backoff = min(2 ** attempt, 30)
                    time.sleep(backoff)
                    continue

                return False

            # Success
            print(f"[+] Posted {payload['embeds'][0]['title']}")
            time.sleep(DISCORD_POST_DELAY_SECONDS)
            return True

        except Exception as e:
            print(f"[!] Discord post failed: {e} (attempt {attempt}/{DISCORD_MAX_RETRIES})")
            backoff = min(2 ** attempt, 30)
            time.sleep(backoff)

    return False


def main_loop() -> None:
    seen_cves = load_seen_cves()
    print(f"[+] Loaded {len(seen_cves)} previously posted CVEs")

    while True:
        print(f"\n[+] Checking CRITICAL CVEs @ {datetime.datetime.now():%Y-%m-%d %H:%M:%S}")

        cves = fetch_critical_cves()
        print(f"[+] Retrieved {len(cves)} CVE entries")

        for entry in cves:
            cve = entry.get("cve") or {}
            cve_id = cve.get("id")
            published_str = cve.get("published")

            if not cve_id or not published_str:
                continue

            # Parse published time and ensure timezone-aware UTC
            try:
                published_date = datetime.datetime.fromisoformat(published_str.replace("Z", "+00:00"))
                if published_date.tzinfo is None:
                    published_date = published_date.replace(tzinfo=datetime.timezone.utc)
                else:
                    published_date = published_date.astimezone(datetime.timezone.utc)
            except Exception:
                continue

            # Only from Jan 9, 2026 onward
            if published_date < MIN_PUBLISHED_DATE:
                continue

            if cve_id in seen_cves:
                print(f"[-] Skipping duplicate {cve_id}")
                continue

            payload = build_discord_payload(entry)
            ok = post_to_discord(payload)

            if ok:
                save_seen_cve(cve_id)
                seen_cves.add(cve_id)
            else:
                print(f"[!] Failed to post {cve_id}; will try again next cycle (not marking as seen).")

        print(f"[+] Sleeping for {CHECK_INTERVAL_HOURS} hours...\n")
        time.sleep(CHECK_INTERVAL_HOURS * 3600)


if __name__ == "__main__":
    try:
        main_loop()
    except KeyboardInterrupt:
        print("\n[!] Exiting gracefully")
